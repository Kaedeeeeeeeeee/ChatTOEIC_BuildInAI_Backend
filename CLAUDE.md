# CLAUDE.md

## ðŸ“‹ ä»“åº“ä¿¡æ¯

**å‰ç«¯ä»“åº“ï¼š** https://github.com/Kaedeeeeeeeeee/ChatTOEIC_BuildInAI_Frontend
**åŽç«¯ä»“åº“ï¼š** https://github.com/Kaedeeeeeeeeee/ChatTOEIC_BuildInAI_Backend

**éƒ¨ç½²åœ°å€ï¼š**
- å‰ç«¯ç”Ÿäº§çŽ¯å¢ƒï¼šå¾…é…ç½® (Vercel)
- åŽç«¯APIåœ°å€ï¼šå¾…é…ç½® (Render)

**è‡ªåŠ¨éƒ¨ç½²è®¾ç½®ï¼š**
- å‰ç«¯ï¼šæŽ¨é€åˆ° ChatTOEIC_BuildInAI_Frontend ä»“åº“ä¼šè‡ªåŠ¨è§¦å‘ Vercel éƒ¨ç½²
- åŽç«¯ï¼šæŽ¨é€åˆ° ChatTOEIC_BuildInAI_Backend ä»“åº“ä¼šè‡ªåŠ¨è§¦å‘ Render éƒ¨ç½²

## ðŸ“ é¡¹ç›®æ–‡ä»¶å¤¹ç»“æž„ä¸Žä»“åº“å¯¹åº”å…³ç³»

**ä¸»å·¥ä½œç›®å½•ï¼š** `ChatTOEIC_bulidinAI/` ï¼ˆæœ¬ç›®å½•ï¼‰

### å‰ç«¯é¡¹ç›®ï¼š
- **æœ¬åœ°ç›®å½•ï¼š** `ChatTOEIC_BuildInAI_Frontend/`
- **è¿žæŽ¥ä»“åº“ï¼š** https://github.com/Kaedeeeeeeeeee/ChatTOEIC_BuildInAI_Frontend
- **éƒ¨ç½²å¹³å°ï¼š** Vercel
- **ç”Ÿäº§åœ°å€ï¼š** å¾…é…ç½®

### åŽç«¯é¡¹ç›®ï¼š
- **æœ¬åœ°ç›®å½•ï¼š** `ChatToeic_BuildInAI_Backend/`
- **è¿žæŽ¥ä»“åº“ï¼š** https://github.com/Kaedeeeeeeeeee/ChatTOEIC_BuildInAI_Backend
- **éƒ¨ç½²å¹³å°ï¼š** Render
- **APIåœ°å€ï¼š** å¾…é…ç½®

### å…¶ä»–ç›¸å…³æ–‡ä»¶å¤¹è¯´æ˜Žï¼š
åœ¨é¡¹ç›®æ ¹ç›®å½• `/Users/user/project/` ä¸‹è¿˜å­˜åœ¨ä»¥ä¸‹æ–‡ä»¶å¤¹ï¼Œä½†å®ƒä»¬ä¸æ˜¯ä¸»è¦å·¥ä½œç›®å½•ï¼š

- `ChatTOEIC-Frontend-Clone/` - å‰ç«¯ä»“åº“çš„å…‹éš†å‰¯æœ¬ï¼ˆå¼€å‘å¤‡ä»½ï¼‰
- `ChatTOEIC-Frontend-Temp/` - ä¸´æ—¶æ–‡ä»¶å¤¹ï¼ˆå®žé™…è¿žæŽ¥åˆ°åŽç«¯ä»“åº“ï¼Œå‘½åæœ‰è¯¯å¯¼æ€§ï¼‰
- `ChatTOEIC/` - åŽç«¯ä»“åº“çš„å¦ä¸€ä¸ªå…‹éš†å‰¯æœ¬

**âš ï¸ é‡è¦æé†’ï¼š**
- ä¸»è¦å¼€å‘å·¥ä½œåº”åœ¨ `ChatTOEIC_bulidinAI/` ç›®å½•ä¸‹è¿›è¡Œ
- è¿™æ˜¯Chrome Built-in AI Challenge 2025çš„ä¸“ç”¨å¼€å‘ç›®å½•
- æ–°ä»“åº“ChatTOEIC_BuildInAI_Frontendå’ŒChatTOEIC_BuildInAI_Backendå°†ç”¨äºŽæ¯”èµ›éƒ¨ç½²

## âš ï¸ å…³é”®éƒ¨ç½²æ³¨æ„äº‹é¡¹

### 1. Verceléƒ¨ç½²é…ç½®é—®é¢˜
**é—®é¢˜ï¼š** å½“ä»“åº“åŒæ—¶åŒ…å«æ ¹ç›®å½•å’Œå­ç›®å½•ï¼ˆå¦‚`frontend/`ï¼‰çš„å®Œæ•´å‰ç«¯é¡¹ç›®æ—¶ï¼ŒVercelé»˜è®¤ä¼šä»Žæ ¹ç›®å½•æž„å»ºï¼Œå¯èƒ½å¯¼è‡´éƒ¨ç½²æ—§ç‰ˆæœ¬ä»£ç ã€‚

**ç—‡çŠ¶è¯†åˆ«ï¼š**
- Gitæäº¤è®°å½•æ˜¾ç¤ºæœ€æ–°ä»£ç å·²æŽ¨é€
- Vercelæ˜¾ç¤ºéƒ¨ç½²æˆåŠŸï¼Œä½†ç½‘ç«™æ˜¾ç¤ºçš„æ˜¯æ—§ç‰ˆæœ¬åŠŸèƒ½
- æœ¬åœ°`frontend/`ç›®å½•çš„ä¿®æ”¹æ²¡æœ‰ä½“çŽ°åœ¨ç”Ÿäº§çŽ¯å¢ƒ

**è§£å†³æ–¹æ¡ˆï¼š**
- åœ¨ä»“åº“æ ¹ç›®å½•åˆ›å»º`vercel.json`é…ç½®æ–‡ä»¶
- æŒ‡å®šæž„å»ºç›®å½•ï¼š`"buildCommand": "cd frontend && npm run build"`
- æŒ‡å®šè¾“å‡ºç›®å½•ï¼š`"outputDirectory": "frontend/dist"`
- æŒ‡å®šå®‰è£…å‘½ä»¤ï¼š`"installCommand": "cd frontend && npm install"`

### 2. vercel.jsoné…ç½®æ–‡ä»¶å†²çª
**é—®é¢˜ï¼š** åŒä¸€ä»“åº“ä¸­å­˜åœ¨å¤šä¸ª`vercel.json`æ–‡ä»¶ï¼ˆæ ¹ç›®å½•ã€`public/`ç›®å½•ã€å­ç›®å½•ç­‰ï¼‰ä¼šé€ æˆé…ç½®å†²çªã€‚

**è§£å†³æ–¹æ¡ˆï¼š**
- åˆ é™¤ä¸å¿…è¦çš„`vercel.json`æ–‡ä»¶ï¼ˆå¦‚`public/vercel.json`ï¼‰
- ä¿æŒå•ä¸€çš„æ ¹ç›®å½•é…ç½®æ–‡ä»¶
- ç¡®ä¿é…ç½®æ–‡ä»¶æŒ‡å‘æ­£ç¡®çš„æž„å»ºç›®å½•

### 3. TypeScriptç¼–è¯‘é”™è¯¯æŽ’æŸ¥
**å¸¸è§é”™è¯¯ç±»åž‹ï¼š**
- å¯¼å…¥è·¯å¾„é”™è¯¯ï¼šæ£€æŸ¥`import`è¯­å¥æ˜¯å¦åŒ¹é…å®žé™…çš„`export`
- é‡å¤ç»„ä»¶å£°æ˜Žï¼šç¡®ä¿ç»„ä»¶åç§°å”¯ä¸€ï¼Œé¿å…åœ¨åŒä¸€æ–‡ä»¶ä¸­é‡å¤å£°æ˜Ž
- APIæœåŠ¡å¯¼å…¥é—®é¢˜ï¼šéªŒè¯æœåŠ¡ç±»çš„æ­£ç¡®å¯¼å‡ºåç§°

**æŽ’æŸ¥æ­¥éª¤ï¼š**
1. æœ¬åœ°è¿è¡Œ`npm run build`æ£€æŸ¥ç¼–è¯‘é”™è¯¯
2. é€ä¸ªä¿®å¤TypeScripté”™è¯¯
3. ç¡®è®¤æ‰€æœ‰å¯¼å…¥è·¯å¾„å’Œå¯¼å‡ºåç§°æ­£ç¡®åŒ¹é…
4. æŽ¨é€ä¿®å¤åŽç­‰å¾…Vercelé‡æ–°éƒ¨ç½²

### 4. éƒ¨ç½²éªŒè¯æ–¹æ³•
**éªŒè¯æ­¥éª¤ï¼š**
1. æ·»åŠ æ˜Žæ˜¾çš„ç‰ˆæœ¬æ ‡è¯†ï¼ˆå¦‚é¡µé¢æ ‡é¢˜ã€ç‰ˆæœ¬å·ç­‰ï¼‰
2. æŽ¨é€æ›´æ”¹å¹¶ç­‰å¾…éƒ¨ç½²å®Œæˆ
3. æ£€æŸ¥ç”Ÿäº§çŽ¯å¢ƒæ˜¯å¦æ˜¾ç¤ºæ–°çš„æ ‡è¯†
4. ç¡®è®¤æ‰€æœ‰æ–°åŠŸèƒ½æ­£å¸¸å·¥ä½œåŽæ¸…ç†ä¸´æ—¶æ ‡è¯†

**è°ƒè¯•æŠ€å·§ï¼š**
- ä½¿ç”¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·æ£€æŸ¥ç½‘ç»œè¯·æ±‚
- æ¸…é™¤æµè§ˆå™¨ç¼“å­˜æˆ–ä½¿ç”¨æ— ç—•æ¨¡å¼
- æ£€æŸ¥Verceléƒ¨ç½²æ—¥å¿—ç¡®è®¤æž„å»ºè¿‡ç¨‹

---

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

ChatTOEIC is a full-stack AI-powered TOEIC practice application that helps users improve their English proficiency through interactive practice sessions, AI-assisted learning, and intelligent vocabulary management.

**Current Technology Stack (v1.3.1):**
- Frontend: React 19 + TypeScript + Vite
- State Management: Zustand
- Styling: Tailwind CSS v4
- Database: IndexedDB (via Dexie) - **MIGRATING TO POSTGRESQL**
- AI Integration: Google Gemini API
- Testing: Vitest + Testing Library
- Routing: React Router v7

**Target Technology Stack (v2.0 - In Development):**
- Frontend: React 19 + TypeScript + Vite (unchanged)
- State Management: Zustand (unchanged)
- Styling: Tailwind CSS v4 (unchanged)
- Backend: Node.js + TypeScript + Express
- Database: PostgreSQL + Prisma ORM
- Authentication: JWT + bcrypt + OAuth 2.0
- AI Integration: Google Gemini API (server-side)
- Testing: Vitest + Testing Library + Jest (backend)
- Deployment: Vercel (frontend) + Render (backend + database)

## Development Commands

```bash
# Navigate to the main application directory
cd ai-toeic-practice

# Development server
npm run dev

# Build for production
npm run build

# Run tests
npm test              # Watch mode
npm run test:run      # Single run
npm run test:ui       # UI mode

# Linting
npm run lint

# Preview production build
npm run preview
```

## Project Architecture

### Directory Structure
```
src/
â”œâ”€â”€ components/          # React components organized by feature
â”‚   â”œâ”€â”€ common/         # Shared components (ErrorBoundary, Modal, etc.)
â”‚   â”œâ”€â”€ home/           # Home page components
â”‚   â”œâ”€â”€ practice/       # Practice session components
â”‚   â”œâ”€â”€ review/         # AI chat and review components
â”‚   â”œâ”€â”€ revision/       # Wrong questions revision
â”‚   â””â”€â”€ layout/         # Layout components
â”œâ”€â”€ stores/             # Zustand state management
â”œâ”€â”€ services/           # Business logic and external API calls
â”œâ”€â”€ types/              # TypeScript type definitions
â”œâ”€â”€ router/             # React Router configuration
â””â”€â”€ utils/              # Utility functions and constants
```

### State Management (Zustand)

The application uses these main stores:

1. **practiceStore** - Manages practice sessions, question generation, and answer submission
2. **chatStore** - Handles AI conversations and chat history  
3. **userStore** - User preferences, settings, and score calculations
4. **vocabularyStore** - Vocabulary management and spaced repetition system

### Service Layer

Key services providing business logic:

- **geminiAPI.ts** - Google Gemini API integration with rate limiting and error handling
- **storageService.ts** - IndexedDB operations using Dexie
- **errorService.ts** - Centralized error handling and logging
- **scoreCalculator.ts** - TOEIC score estimation algorithms
- **prompts.ts** - AI prompt templates and builders

## Key Features

### AI Integration
- Question generation using Gemini API
- Interactive AI chat for learning assistance
- Intelligent error analysis and explanations
- API key management with local storage

### Practice System
- Configurable practice sessions (difficulty, question count, time limits)
- Real-time progress tracking
- Wrong question collection for revision
- Score estimation based on performance

### Data Persistence
- Offline-first architecture using IndexedDB
- Practice history and chat logs storage
- Data export/import functionality
- Automatic backup and health checks

## Development Guidelines

### API Key Setup
The application requires a Google Gemini API key. Users configure this through the UI, and it's stored in localStorage. For development:

1. Get API key from Google AI Studio
2. Configure through the application UI or set in localStorage as 'gemini_api_key'

### Error Handling
- All API calls go through centralized error handling in `errorService`
- Network errors are handled gracefully with retry mechanisms  
- Offline fallbacks are provided where possible

### Testing Strategy
- Component tests use Testing Library
- Service layer has comprehensive unit tests
- Integration tests cover API interactions
- Test setup includes jsdom environment

### TypeScript Usage
- Strict type checking enabled
- Comprehensive type definitions in `src/types/`
- Type guards and validation functions provided
- Runtime type validation for external data

## Common Development Tasks

### Adding New Question Types
1. Update `QuestionType` enum in `src/types/question.ts`
2. Modify question generation prompts in `src/services/prompts.ts`
3. Update UI components to handle new question format
4. Add corresponding tests

### Extending AI Capabilities
1. Create new prompt templates in `src/services/prompts.ts`
2. Add new methods to `GeminiAPIService` class
3. Update relevant stores to use new AI features
4. Handle new error scenarios

### Adding New Storage Entities
1. Define new table in `src/services/storageService.ts`
2. Create corresponding TypeScript types
3. Add CRUD operations and validation
4. Update backup/restore functionality

## Configuration

### Environment Variables
No environment variables are required. Configuration is handled through:
- User preferences stored in IndexedDB
- API keys stored in localStorage
- Build-time configuration in `vite.config.ts`

### Gemini API Configuration
- Model: gemini-1.5-flash
- Rate limits: 60 requests/minute, 1000 requests/day
- Request timeout: 30 seconds
- Retry logic with exponential backoff

## Troubleshooting

### Common Issues
1. **API Rate Limits** - Check rate limit status in developer tools
2. **Storage Quota** - Monitor IndexedDB usage via storage health checks
3. **Network Errors** - Verify API key and network connectivity
4. **Build Errors** - Ensure TypeScript types are correctly defined

### Debug Tools
- Error service provides detailed error logging
- Storage service includes health check utilities
- Rate limit status can be queried from GeminiAPIService
- React dev tools for component inspection

## Performance Considerations

- Questions are generated in batches to minimize API calls
- Chat history is paginated to avoid memory issues
- IndexedDB operations are optimized with proper indexing
- Component lazy loading for route-based code splitting
- Zustand provides efficient state updates without unnecessary re-renders

---

# ðŸ“‹ ChatTOEIC v2.0 Full-Stack Migration Plan

## ðŸŽ¯ Architecture Overview

**System Architecture:**
```
User Browser
    â†“ HTTPS
Frontend (React + Vite) on Vercel
    â†“ REST API
Backend (Node.js + Express) on Render
    â†“ SQL Queries
PostgreSQL Database on Render
    â†“ External API
Google Gemini API (server-side)
```

**Authentication Flow:**
```
1. User Registration/Login â†’ Backend API
2. Backend validates â†’ PostgreSQL
3. Backend generates JWT â†’ Returns to Frontend  
4. Frontend stores JWT â†’ Includes in API requests
5. Backend validates JWT â†’ Processes requests
```

## ðŸ—„ï¸ Database Design (PostgreSQL)

### Core Tables Structure:

```sql
-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE,
    username VARCHAR(100) NOT NULL,
    avatar_url VARCHAR(500),
    preferences JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    last_login TIMESTAMP
);

-- Authentication methods (supports multiple login types)
CREATE TABLE user_auths (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    auth_type VARCHAR(20) NOT NULL, -- 'email', 'google', 'wechat'
    auth_id VARCHAR(255) NOT NULL,  -- email/provider ID
    password_hash VARCHAR(255),     -- only for email auth
    provider_data JSONB,            -- third-party data
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(auth_type, auth_id)
);

-- Practice sessions
CREATE TABLE practice_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    session_type VARCHAR(50) NOT NULL,
    difficulty VARCHAR(20) NOT NULL,
    questions JSONB NOT NULL,
    answers JSONB,
    score INTEGER,
    part_scores JSONB,
    time_spent INTEGER,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Vocabulary system
CREATE TABLE vocabulary_words (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    word VARCHAR(255) NOT NULL,
    definition TEXT,
    phonetic VARCHAR(100),
    audio_url VARCHAR(500),
    context TEXT,
    meanings JSONB,
    review_data JSONB,
    tags TEXT[],
    mastered BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, word)
);

-- AI Chat sessions
CREATE TABLE chat_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    context_type VARCHAR(50),
    context_id UUID,
    messages JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- API usage tracking
CREATE TABLE api_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    api_type VARCHAR(50),
    tokens_used INTEGER,
    cost_usd DECIMAL(10,4),
    created_at TIMESTAMP DEFAULT NOW()
);
```

### Database Indexes:
```sql
-- Performance indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_sessions_user_created ON practice_sessions(user_id, created_at DESC);
CREATE INDEX idx_vocabulary_user_word ON vocabulary_words(user_id, word);
CREATE INDEX idx_chat_user_context ON chat_sessions(user_id, context_type, context_id);

-- Full-text search for vocabulary
CREATE INDEX idx_vocabulary_search ON vocabulary_words 
USING GIN (to_tsvector('english', word || ' ' || COALESCE(definition, '')));
```

## ðŸ”’ Authentication System Design

### JWT Implementation:
```typescript
// JWT Payload Structure
interface JWTPayload {
  userId: string;
  email?: string;
  username: string;
  authMethods: string[];
  iat: number;
  exp: number;
}

// Token Management
const accessToken = jwt.sign(payload, JWT_SECRET, { expiresIn: '15m' });
const refreshToken = jwt.sign({ userId }, REFRESH_SECRET, { expiresIn: '7d' });
```

### OAuth Integration:
```typescript
// Google OAuth Flow
app.get('/api/auth/google', passport.authenticate('google'));
app.get('/api/auth/google/callback', 
  passport.authenticate('google'),
  (req, res) => {
    const token = generateJWT(req.user);
    res.redirect(`${FRONTEND_URL}?token=${token}`);
  }
);

// WeChat OAuth (future)
app.get('/api/auth/wechat', (req, res) => {
  const authUrl = `https://open.weixin.qq.com/connect/qrconnect?appid=${WECHAT_APP_ID}&redirect_uri=${CALLBACK_URL}`;
  res.redirect(authUrl);
});
```

## ðŸš€ API Endpoints Design

### Authentication Endpoints:
```typescript
POST   /api/auth/register           // Email registration
POST   /api/auth/login              // Email login
POST   /api/auth/refresh            // Refresh JWT token
POST   /api/auth/logout             // Logout (blacklist token)
GET    /api/auth/google             // Google OAuth initiate
GET    /api/auth/google/callback    // Google OAuth callback
GET    /api/auth/wechat             // WeChat OAuth initiate
GET    /api/auth/wechat/callback    // WeChat OAuth callback
```

### Practice Endpoints:
```typescript
GET    /api/practice/sessions       // Get user's practice history
POST   /api/practice/sessions       // Create new practice session
PUT    /api/practice/sessions/:id   // Update session (submit answers)
DELETE /api/practice/sessions/:id   // Delete session
POST   /api/practice/questions      // Generate questions via Gemini API
```

### Vocabulary Endpoints:
```typescript
GET    /api/vocabulary              // Get user's vocabulary words
POST   /api/vocabulary              // Add new word
PUT    /api/vocabulary/:id          // Update word (notes, review data)
DELETE /api/vocabulary/:id          // Delete word
GET    /api/vocabulary/review       // Get words needing review
POST   /api/vocabulary/review/:id   // Mark word as reviewed
GET    /api/vocabulary/search       // Search vocabulary
```

### AI Chat Endpoints:
```typescript
GET    /api/chat/sessions           // Get chat sessions
POST   /api/chat/sessions           // Create new chat session
POST   /api/chat/message            // Send message to AI
PUT    /api/chat/sessions/:id       // Update chat session
```

### User Management:
```typescript
GET    /api/user/profile            // Get user profile
PUT    /api/user/profile            // Update user profile
GET    /api/user/stats              // Get learning statistics
POST   /api/user/export             // Export user data
POST   /api/user/import             // Import user data
DELETE /api/user/account            // Delete user account
```

## ðŸ“¦ Backend Project Structure

```
chattoeic-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/          # Route handlers
â”‚   â”‚   â”œâ”€â”€ authController.ts
â”‚   â”‚   â”œâ”€â”€ practiceController.ts
â”‚   â”‚   â”œâ”€â”€ vocabularyController.ts
â”‚   â”‚   â””â”€â”€ chatController.ts
â”‚   â”œâ”€â”€ middleware/           # Express middleware
â”‚   â”‚   â”œâ”€â”€ auth.ts          # JWT verification
â”‚   â”‚   â”œâ”€â”€ rateLimiter.ts   # API rate limiting
â”‚   â”‚   â”œâ”€â”€ validation.ts    # Request validation
â”‚   â”‚   â””â”€â”€ errorHandler.ts  # Error handling
â”‚   â”œâ”€â”€ services/            # Business logic
â”‚   â”‚   â”œâ”€â”€ authService.ts   # Authentication logic
â”‚   â”‚   â”œâ”€â”€ geminiService.ts # AI API integration
â”‚   â”‚   â”œâ”€â”€ emailService.ts  # Email notifications
â”‚   â”‚   â””â”€â”€ encryptionService.ts # Data encryption
â”‚   â”œâ”€â”€ models/              # Database models (Prisma)
â”‚   â”‚   â””â”€â”€ schema.prisma    # Database schema
â”‚   â”œâ”€â”€ routes/              # API routes
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ practice.ts
â”‚   â”‚   â”œâ”€â”€ vocabulary.ts
â”‚   â”‚   â””â”€â”€ chat.ts
â”‚   â”œâ”€â”€ utils/               # Utility functions
â”‚   â”‚   â”œâ”€â”€ jwt.ts
â”‚   â”‚   â”œâ”€â”€ bcrypt.ts
â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â””â”€â”€ constants.ts
â”‚   â”œâ”€â”€ types/               # TypeScript types
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ practice.ts
â”‚   â”‚   â””â”€â”€ api.ts
â”‚   â””â”€â”€ app.ts               # Express app setup
â”œâ”€â”€ prisma/                  # Database migrations
â”‚   â”œâ”€â”€ migrations/
â”‚   â””â”€â”€ seed.ts             # Database seeding
â”œâ”€â”€ tests/                   # Test files
â”‚   â”œâ”€â”€ auth.test.ts
â”‚   â”œâ”€â”€ practice.test.ts
â”‚   â””â”€â”€ vocabulary.test.ts
â”œâ”€â”€ docker-compose.yml       # Local development
â”œâ”€â”€ Dockerfile              # Production build
â””â”€â”€ package.json
```

## ðŸ”„ Migration Strategy

### Phase 1: Backend Infrastructure (Week 1-2)
1. Set up Node.js + Express project
2. Configure PostgreSQL + Prisma
3. Implement basic authentication (email + JWT)
4. Create core database models
5. Set up development environment (Docker)

### Phase 2: Authentication System (Week 3)
1. Implement user registration/login
2. Add JWT middleware
3. Create protected route handlers
4. Frontend authentication integration
5. Add Google OAuth integration

### Phase 3: Data Migration (Week 4-5)
1. Create data migration scripts (IndexedDB â†’ PostgreSQL)
2. Implement practice session APIs
3. Migrate vocabulary system
4. Update frontend to use backend APIs
5. Maintain backward compatibility during transition

### Phase 4: AI Integration & Polish (Week 6-7)
1. Move Gemini API calls to backend
2. Implement chat session management
3. Add API usage tracking
4. Security hardening
5. Performance optimization
6. Production deployment

### Phase 5: Advanced Features (Week 8+)
1. WeChat OAuth integration
2. Advanced analytics
3. Email notifications
4. Data export/import
5. Admin panel

## ðŸ›¡ï¸ Security Considerations

### Data Protection:
- Password hashing with bcrypt (salt rounds: 12)
- JWT secrets stored in environment variables
- HTTPS enforcement
- CORS configuration
- Rate limiting on sensitive endpoints
- Input validation and sanitization
- SQL injection prevention (Prisma ORM)

### API Security:
```typescript
// Rate limiting example
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  standardHeaders: true,
  legacyHeaders: false,
});

// Input validation example
const registerSchema = z.object({
  email: z.string().email().max(255),
  password: z.string().min(12).max(128),
  username: z.string().min(2).max(50),
});
```

### Privacy Compliance:
- GDPR-compliant data deletion
- User consent management
- Data encryption at rest
- Audit logging for sensitive operations
- Regular security updates

## ðŸ“ˆ Monitoring & Analytics

### Performance Metrics:
- API response times
- Database query performance  
- User engagement metrics
- Error rates and types
- AI API usage and costs

### Logging Strategy:
```typescript
// Structured logging with Winston
logger.info('User login attempt', {
  userId: user.id,
  email: user.email,
  ip: req.ip,
  userAgent: req.get('User-Agent'),
  success: true,
  timestamp: new Date()
});
```

## ðŸ’° Cost Management

### Development Costs:
- Render: $0 (within free tier)
- Development tools: $0-99 (optional)
- Domain: $10-15/year (optional)

### Production Estimates:
- Render (backend + database): $10-25/month
- Vercel (frontend): $0 (free tier)
- Gemini API: Pay-per-use (estimated $5-20/month)
- **Total: $15-50/month** (scales with usage)

## ðŸ§ª Testing Strategy

### Backend Testing:
- Unit tests: Jest + Supertest
- Integration tests: Database + API endpoints
- Authentication tests: JWT + OAuth flows
- Load testing: Artillery or k6

### End-to-End Testing:
- Playwright for user flows
- Authentication scenarios
- Practice session workflows
- Vocabulary management

---

# ðŸ“‹ Development TODO List

This comprehensive TODO list will guide the v2.0 full-stack migration. Each phase builds upon the previous one, ensuring a systematic and safe transition from the current IndexedDB-based frontend-only application to a full-stack architecture.

## ðŸ“Š Timeline Estimates

- **Phase 1-2**: Backend Infrastructure & Auth (2-3 weeks)
- **Phase 3-4**: Frontend Integration & Practice Migration (2-3 weeks)
- **Phase 5-6**: Vocabulary & Chat Migration (2 weeks)
- **Phase 7-8**: Production Deployment & Testing (1-2 weeks)
- **Phase 9-10**: Advanced Features & Documentation (2-4 weeks)

**Total Estimated Time: 9-14 weeks** (2-3.5 months)

## ðŸŽ¯ Success Criteria

### Phase Completion Criteria:

**Phase 1 Complete When:**
- âœ… Backend server runs locally via Docker
- âœ… PostgreSQL database accessible via pgAdmin
- âœ… Prisma migrations work correctly
- âœ… Basic health check endpoint responds

**Phase 2 Complete When:**
- âœ… Users can register with email/password
- âœ… Users can login and receive JWT tokens
- âœ… JWT middleware protects routes correctly
- âœ… Google OAuth login works end-to-end

**Phase 3 Complete When:**
- âœ… Frontend can authenticate with backend
- âœ… Auth state persists across browser sessions
- âœ… Protected routes redirect properly
- âœ… User profile displays correctly

**Phase 4 Complete When:**
- âœ… Practice sessions save to PostgreSQL
- âœ… Questions generate via backend API
- âœ… Existing IndexedDB data migrates successfully
- âœ… Score calculation works with new data

**Phase 5 Complete When:**
- âœ… Vocabulary CRUD operations work via API
- âœ… Spaced repetition algorithm runs server-side
- âœ… Full-text search returns relevant results
- âœ… Existing vocabulary data migrates successfully

**Phase 6 Complete When:**
- âœ… AI chat sessions persist across devices
- âœ… Chat context links to practice sessions
- âœ… Gemini API calls route through backend
- âœ… Chat history paginated and searchable

**Phase 7 Complete When:**
- âœ… Application deploys successfully to Render
- âœ… Database backups configured and tested
- âœ… HTTPS certificates active
- âœ… Environment variables secured

**Phase 8 Complete When:**
- âœ… >80% test coverage on critical paths
- âœ… All API endpoints tested
- âœ… Security vulnerabilities addressed
- âœ… Performance meets benchmarks

## ðŸ”§ Development Standards

### Code Quality Requirements:
- **TypeScript strict mode**: All code must pass strict type checking
- **ESLint compliance**: Follow established linting rules
- **Test coverage**: >70% coverage for new backend code
- **API documentation**: All endpoints documented with OpenAPI spec
- **Error handling**: Consistent error responses and logging

### Security Requirements:
- **Input validation**: All user inputs validated with Zod schemas
- **Rate limiting**: Applied to all public endpoints
- **JWT security**: Short-lived access tokens (15min) with refresh tokens
- **HTTPS only**: No HTTP traffic in production
- **Environment variables**: All secrets stored securely

### Database Standards:
- **Migration-driven**: All schema changes via Prisma migrations
- **Foreign key constraints**: Proper referential integrity
- **Indexing**: Performance-critical queries must be indexed  
- **Backup verification**: Regular backup restoration tests
- **Data validation**: Database constraints match application logic

## ðŸ“ˆ Monitoring & KPIs

### Development Metrics:
- **API Response Time**: <200ms for 95th percentile
- **Database Query Time**: <50ms for common queries
- **Test Execution Time**: Full test suite <5 minutes
- **Build Time**: Backend + Frontend <3 minutes
- **Deployment Time**: <5 minutes end-to-end

### Production Metrics:
- **Uptime**: >99.9% availability
- **Error Rate**: <1% of requests result in 5xx errors
- **User Authentication**: <2% login failure rate
- **Data Consistency**: Zero data loss incidents
- **API Usage**: Track costs stay within budget

## ðŸš¨ Risk Management

### Technical Risks & Mitigation:
1. **Data Migration Failures**
   - Mitigation: Extensive testing with production-like data
   - Rollback: Maintain IndexedDB as fallback during transition

2. **Authentication Security Issues**
   - Mitigation: Security audit and penetration testing
   - Monitoring: Automated security scanning in CI/CD

3. **Database Performance Problems**
   - Mitigation: Load testing and query optimization
   - Monitoring: Real-time performance alerts

4. **Third-party API Failures** (Gemini, OAuth)
   - Mitigation: Circuit breakers and graceful degradation
   - Fallbacks: Cached responses and offline modes

### Business Risks & Mitigation:
1. **Extended Downtime During Migration**
   - Mitigation: Blue-green deployment strategy
   - Communication: User notifications about maintenance windows

2. **User Experience Regression**
   - Mitigation: A/B testing and gradual rollout
   - Rollback: Quick revert to previous version capability

3. **Budget Overrun**
   - Monitoring: Daily cost tracking and alerts
   - Controls: Usage quotas and circuit breakers

## ðŸ“š Additional Resources

### Essential Documentation:
- [Prisma Documentation](https://www.prisma.io/docs/)
- [Express.js Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)
- [JWT Best Current Practices](https://datatracker.ietf.org/doc/html/rfc8725)
- [OAuth 2.0 Security Best Practices](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)
- [PostgreSQL Performance Tuning](https://www.postgresql.org/docs/current/performance-tips.html)

### Development Tools:
- **API Testing**: Thunder Client (VS Code) or Postman
- **Database Management**: pgAdmin or TablePlus
- **Monitoring**: Render built-in monitoring
- **Logging**: Winston for structured logging
- **Testing**: Jest + Supertest for API testing

---

**Next Steps**: Begin with Phase 1 by creating the backend project structure. The TodoWrite tool above contains the detailed task breakdown for systematic implementation.

**Remember**: Each completed phase should be thoroughly tested before proceeding to the next. The migration strategy prioritizes data safety and user experience continuity above development speed.